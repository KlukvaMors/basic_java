<img src="img/1200px-Java_logo.svg.png" alt="Java — Википедия" width=300 />



- Конспект лекций по курсу **[Java. Базовый курс](https://stepik.org/course/187/info)**
- Преподаватель: **[Алексей Владыкин](https://stepik.org/users/1647194)**
- Конспектировал: **[Курочкин Михаил](https://github.com/KlukvaMors)**



# 0. Содержание



#### 0.1 Введение в Java

- [1. Введение в Java](#1-Введение-в-Java)
  
    - [1.1 Что такое Java, откуда она взялась и зачем нужна](#11-Что-такое-Java-откуда-она-взялась-и-зачем-нужна)
    - [1.2 Первый контакт — Hello World](#12-Первый-контакт--Hello-World)
      - [1.2.1 Компиляция и исполнение](#121-Компиляция-и-исполнение)
    - [1.3 Популярность Java](#13-Популярность-Java)
      - [1.3.1 Платформонезависимость](#131-Платформонезависимость)
    - [1.4 JDK vs JVM VS JRE](#14-JDK-vs-JVM-VS-JRE)
    - [1.3 Знакомство со средой разработки](#13-Знакомство-со-средой-разработки)
    
#### 0.2 Базовый синтаксис Java    

- [2. Базовый синтаксис Java](#2-Базовый-синтаксис-Java)
    - [2.1 Примитивные типы](#21-Примитивные-типы)
      - [2.1.1 Целочисленные](#211-Целочисленные)
        - [2.1.1.1 Различные виды записи целых чисел](#2111-Различные-виды-записи-целых-чисел)
      - [2.1.2 С плавающей точкой](#212-С-плавающей-точкой)
      - [2.1.3 Логический тип](#213-Логический-тип)
      - [2.1.4 Символьный тип](#214-Символьный-тип)
      - [2.1.5 Классы обертки примитивных типов](#215-Классы-обертки-примитивных-типов)
    - [2.2 Преобразование типов](#22-Преобразование-типов)
    - [2.3 Ссылочные типы данных](#23-Ссылочные-типы-данных)
    - [2.3 Массивы](#23-Массивы)
      - [Объявление-и-создание-массивов](Объявление-и-создание-массивов)
      - [Инициализация элементов массива](#Инициализация-элементов-массива)
      - [Многомерные массивы](#Многомерные-массивы)
    - [2.4 Строки String](#24-Строки-String)
      - [2.4.1 Строки VS массив символов](#241-Строки-VS-массив-символов)
      - [2.4.2 Где хранятся строки?](#242-Где-хранятся-строки)
      - [2.4.3 String vs StringBuffer vs StringBuilder](#243-String-vs-StringBuffer-vs-StringBuilder)
    - [2.5 Управляющие конструкции](#25-Управляющие-конструкции)
      - [2.5.1 Оператор if](#251-Оператор-if)
      - [2.5.2 Оператор switch](#252-Оператор-switch)
      - [2.5.3 Цикл while](#253-Цикл-while)
      - [2.5.4 Цикл do while](#254-Цикл-do-while)
      - [2.5.5 Цикл for](#255-Цикл-for)
      - [2.5.6 Цикл foreach](#256-Цикл-foreach)
      - [2.5.7 Оператор break](#257-Оператор-break)
      - [2.5.8 Оператор continue](#258-Оператор-continue)
      - [2.5.9 Метки](#259-Метки)

#### 0.3 Объекты, классы и пакеты  

- [3. Объекты, классы и пакеты в Java](#3-Объекты-классы-и-пакеты-в-Java)
  
    - [3.1 Основы ООП](#31-Основы-ООП)
      - [3.1.1 Абстракция](#311-Абстракция)
      - [3.1.2 Инкапсуляция](#312-Инкапсуляция)
      - [3.1.3 Наследование](#313-Наследование)
      - [3.1.4 Полиморфизм](#314-Полиморфизм)
    - [3.2 Пакеты и модификаторы доступа](#32-Пакеты-и-модификаторы-доступа)
    - [3.3 Объявление класса](#33-Объявление-класса)
    - [3.4 Наследование. Класс Object](#34-Наследование-Класс-Object)
    - [3.5 Абстрактные классы и интерфейсы](#35-Абстрактные-классы-и-интерфейсы)

#### 0.4 Обработка ошибок, исключения, отладка

- [4. Обработка ошибок, исключения, отладка](#4-Обработка-ошибок-исключения,-отладка)
  
    - [4.1 Знакомство с исключениями](#41-Знакомство-с-исключениями)
      - [4.1.1 Типы исключений](#411-Типы-исключений)
      - [4.1.2 Иерархия ислючений](#412-Иерархия-ислючений)
      - [4.1.3 Создание собственного исключения](#413-Создание-собственного-исключения)
    - [4.2 Обработка исключений. Try-catch](#42-Обработка-исключений-Try-catch)
    - [4.3 Логирование](#43-Логирование)

#### 0.5 Ввод-вывод, доступ к файловой системе

- [5. Ввод-вывод, доступ к файловой системе](#5-Ввод-вывод-доступ-к-файловой-системе)
    - [5.1 Доступ к файловой системе](#51-Доступ-к-файловой-системе)
    - [5.2 Потоки байт](#52-Потоки-байт)
    - [5.3 Потоки символов](#53-Потоки-символов)
    - [5.4 Продвинутые возможности](#54-Продвинутые-возможности)

#### 0.6 Generics. Collections. Streams

- [6. Generics. Collections. Streams](#6-Generics-Collections-Streams)
    - [6.1 Generics](#61-Generics)
    - [6.2 Коллекции](#62-Коллекции)
      - [6.2.1 Интерфейс Collection](#621-Интерфейс-Collection)
      - [6.2.2 Интерфейс List](#622-Интерфейс-List)
      - [6.2.3 Интерфейс Queue](#623-Интерфейс-Queue)
      - [6.2.4 Интерфейс Deque](#624-Интерфейс-Deque)
    - [6.3 Функциональные интерфейсы](#63-Функциональные-интерфейсы)
    - [6.4 Stream API](#64-Stream-API)



# 1. Введение в Java

[К содержанию](#0-Содержание)

> You know why the java coders wear glasses?
> No, why?
> Because they don't c#



## 1.1 Что такое Java, откуда она взялась и зачем нужна

[Начало главы](#1-Введение-в-Java)

<img src="img/duke-small-1.png" alt="Что нового в Java 12 - The blog of a gypsy engineer" width=300 />

Парень Дюк смешной отвязный, а язык то нет. 





## 1.2 Первый контакт — Hello World

[Начало главы](#1-Введение-в-Java)

Hello world на Java :coffee: уже сам по себе довольно изъёбистый :expressionless: , что не обещает на ничего хорошо, но на что не идёт java программисты ради денег :money_mouth_face: .

**Java**

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

Его младший братик C sharp ничем не лучше его в написание первой программы.

**C sharp**

```C sharp
namespace HelloWorld
{
    class Hello {        
        static void Main(string[] args)
        {
            System.Console.WriteLine("Hello World");
        }
    }
}
```

Мой любымий питонячий язык :snake: конечно же всех уделывает :grinning:

**Python**

```python
print("Hello World")
```



### 1.2.1 Компиляция и исполнение

**использование java and javaс**

Чтобы выполнить java код, нужно сделать две вещи:

1. Скомпилировать в байт код

2. Запустить байт код

   

**Компиляция**

Для компиляции java кода используется команда `javac`

- Откроем CommandPrompt/Terminal и cd (перейдём) в папку где хранится **HelloWorld.java**
- Выполним команду ниже

```
javac HelloWorld.java
```

- В этой же директории появится новый файл **HelloWorld.class** 

- **HelloWorld.class** это файл с байт кодом

  

**Исполнение байт кода**

```
java HelloWorld
```

- В консоле должен появится текст `Hello World`



## 1.3 Популярность Java

- Платформонезависимость и портируемость
- ООП язык 
- Безопасность 
- Богатое API
- Вездеприсущий
  - Web Applications (Java EE (JSP, Servlets), Spring, Struts..)
  - Mobile Apps(Android)
  - Microservices (Spring Boot)



#### 1.3.1 Платформонезависимость

Скомпилировано один раз (в байт код), работает везде.

![java-write-once-run-anywhere.png](img/java-write-once-run-anywhere.png)

## 1.4 JDK vs JVM VS JRE

- JVM (Java Virtual Machine)
  - запускает Java bytecode.
- JRE
  - **JVM** + Libraries + Other Components (to run applets and other java applications)
- JDK
  - **JRE** + Compilers + Debuggers

![](img/JVM-JRE-JDK.drawio.png)

## 1.3 Знакомство со средой разработки

[Начало главы](#1-Введение-в-Java)



# 2. Базовый синтаксис Java

[К содержанию](#0-Содержание)



## 2.1 Примитивные типы

[Начало главы](#2-Базовый-синтаксис-Java)

В Java есть **8** примитивных типов, которые делят на группы:

1. Целые числа - `byte`, `short`, `int`, `long`
2. Числа с плавающей точкой - `float`, `double`
3. Логический - `boolean`
4. Символьный - `char` (часто причисляют к целым числам)

### 2.1.1 Целочисленные

| Тип данных | Бит  | Диапазон                                                 | Порядок ~          |
| ---------- | ---- | -------------------------------------------------------- | ------------------ |
| byte       | 8    | -128 ... 127                                             | +- сотня           |
| short      | 16   | -32 768 ... 32 767                                       | +- 30 тысяч        |
| int        | 32   | -2 147 483 648 ... 2 147 483 647                         | +- 2 милиарда      |
| long       | 64   | -9 223 372 036 854 775 808 ... 9 223 372 036 854 775 807 | +- 9 квинтиллионов |
| char       | 16   | 0 ... 65535 (хранит символы в формате UTF-16)            |                    |


```java
byte b = 216; // Вот тут будет ошибка, т.к. у нас диапазон от -128 до 127!
short s = 1123;
int i = 64536;
long l = 2147483648L; // Постфикс l или L обозначает литералы типа long
//рекомендуется использовать постфикс L, так как l м.б. похоже на единицу
int i1 = 2_147_483_647; //для удобства чтения числ человеком их можно записывать так

```



#### 2.1.1.1 Различные виды записи целых чисел

```java
int decimal = 99;
int octal = 0755;
int hex = 0xFF;
int binary = 0b101;
int tenMillion = 10 _000_000;
long tenBillion = 10 _000_000_000L;
```



### 2.1.2 С плавающей точкой

| Тип данных | Бит  | Мантисса (бит) | Порядок (бит)  |
| ---------- | ---- | -------------- | -------------- |
| float      | 32   | 23             | `32 - 23 = 9`  |
| double     | 64   | 52             | `64 - 52 = 12` |



```java
double a, b = 4.12;
a = 22.1 + b;
float pi = 3.14f; // При использовании типа float требуется указывать суффикс f или F
// так как без них типом литерала будет считаться double
float anotherPi = (float) 3.14; // Можно привести явно
double c = 27;
double d = pi * c;
```



**TODO**: описать, что такое мантисса и порядок

### 2.1.3 Логический тип

| Тип данных | Бит  | Значения        |
| ---------- | ---- | --------------- |
| boolean    | 8    | `true`, `false` |

```java
// прямое присваивание
boolean brushedTeethToday = true;
boolean haveDog = false;
// как результат условия
boolean iKnowMath = 1 < 100;
// Main.java:3: error: incompatible types: int cannot be converted to boolean
boolean fromInt = 10;
```

К типу `boolean` можно применять логические операции

```java
//логическое отрицание
boolean haveSpareTime = !isBusy;
//логическое "И"
boolean canGoToPark = haveSpareTime && weatherIsGood;
//логическое "ИЛИ"
boolean hadGoodTime = learnedJavaOnStepic || wentToPark;
//логическое исключающее "ИЛИ"
boolean tastesGood = addedKetchup ^ addedHoney;
```



### 2.1.4 Символьный тип

| Тип данных | Бит  | Диапазон                                      | Значения                     |
| ---------- | ---- | --------------------------------------------- | ---------------------------- |
| char       | 16   | 0 ... 65535 (хранит символы в формате UTF-16) | `'a'`, `'\n'`, `'1'`, `'\\'` |



### 2.1.5 Классы обертки примитивных типов

| Примитивный тип | Класс обёртка |
| --------------- | ------------- |
| boolean         | Boolean       |
| byte            | Byte          |
| short           | Short         |
| int             | Integer       |
| long            | Long          |
| char            | Character     |
| float           | Float         |
| double          | Double        |



## 2.2 Преобразование типов

[Начало главы](#2-Базовый-синтаксис-Java)



![img](img/cfe9124f-ca55-4834-8dd8-6d90ed8ab3ac.png)



![JavaBasics_ImplicitTypeCastingPrimitivesDetailedTable](img/JavaBasics_ImplicitTypeCastingPrimit%255B1%255D.png)



## 2.3 Ссылочные типы данных

[Начало главы](#2-Базовый-синтаксис-Java)

Все типы отличные от примитивов в Java это объекты. Доступ к объекту осуществляется по ссылке. 



Объявляем ячейку памяти, в которой будет хранится объект типа `BigInteger`.
На данный момент никакой объект не создался, а ячейка вместо ссылки хранит значение `null`.

```java
BigInteger number; 
```

Создаём объект типа `BigInteger` и помещаем ссылку на него в ячейку памяти по названием `number`.
Сами объекты хранятся в `Heap` а ссылки на них в `Stack`.
Ключевое слово `new` также вызывает конструктор объекта

```java
number = new BigInteger("123456");
```

Объект удаляется автоматически с помощью сборщика мусора `Garbage Collector` :broom: .
Сборщик мусора удаляет объект, когда в программе не осталось таких ссылок, по который можно было бы добраться до объекта.
На это свойство можно посмотреть под углом философии: человек умирает тогда, когда на него уже ничего не указывает ничто.
Соответственно поэтому Цой жив :metal: :guitar:!
По этому же определению могут быть живые телом люди, которые мертвы, если на них ничто не указывает.

А ты, друг мой, живой :question: 

```java
number = null; //удаляем ссылку, сейчас на объект ничего не указывает
```

Но это не обозначает, что сборщик мусора удалил объект прямо сейчас.
Сборщик мусора вызывается произвольно.
Произвольный запуск сборщика мусора может вызывать баттхёрт :confounded: и геморрой у программистов и пользователей Java программ.

> Представьте вы на свидание и вдруг придавило клапан :flushed:
> Вы ищете сборщик мусора :toilet: , который уберёт остатки переработанной картошечки :bowl_with_spoon: с селёдочкой съеденной накануне.
> Вы находите умный клозет :wc: под управлением Java программы :coffee:
> Кидаете монетку :moneybag: дабы войти в сее чудо техники, но на моменте оплаты Java-сборщик-мусора решает почистить свою память.
> Туалет зависает, ваш клапан пробивает, свидание испорчено, платье испачкана





## 2.3 Массивы

[Начало главы](#2-Базовый-синтаксис-Java)

#### Объявление и создание массивов

```java
int[] a;//массивы объявляются так
int b[]; // или разночачно так, но лучше делать первым способом
// сейчас мы объявили ссылку на массив, но создали их
a = new int[100]; //создали массив со 100 элементами
//каждый элемент массивы по умолчанию заполняется значениями, для числочисленных типов это 0
boolean[] bits = new boolean[8]; //объявлять и создавать массивы можно одновремено
// в boolean значение по умолчанию будет false
String[] strs = new String[4]; //также массив может состоять из ссылочных типов данных
//они заполняются по умолчанию значениями null
```

#### Инициализация элементов массива

```java
int[] a = new int[] {1, 2, 3, 4, 5, 6};
//при создание можно перечислить элементы, которые будут храниться в массиве
int[] b = {1, 2, 3, 4, 5, 6};
// эта запись имеет и короткую форму, но такая запись позволительна когда мы объявляем и создаём массив одновремено, как тут

int length = b.length;//длинна массива
int first = b[0];//обращение к первому элементу
int last = b[b.length -1];////обращение к последнему элементу
int indexOutOfBound = b[b.length];//обращение к несуществующему элементу вызовет исключение
```

#### Многомерные массивы

```java
int[][] maxrix1 = new int[][];

int[][] maxrix2 = new {{1, 2},
                       {3, 4}};

int[] firstRow = matrix2[0];

int someElement = matrix2[1][1];

int[][] triangle = {
    {1, 2, 3, 4, 5},
    {6, 7, 8, 9},
    {10, 11, 12},
    null,
    {13, 14},
    {15}
};
```



#### Аргументы переменной длины

Синтаксис выглядит для переменных типа `String` следующим образом:

```java
public void getData(String ... data){

   //your code here...

}
```

В языке Java эта возможность появилась начиная с JDK5.

Для чего же такой функционал может понадобиться? Вариантов множество. Самый простой - Вам нужно реализовать метод **sum()**, который будет суммировать два числа. Правда, что тут сложного:

```java
public class Summator {

   public static void main(String[] s){
      int x = 5;
      int y = 5;
      int res = sum(x, y);
      System.out.println(res);

   }

   public static int sum(int a, int b){
      return a+b;
   }

}
```

На следующий день к Вам забегает заказчик и говорит что задача изменилась, и в метод **sum()** нужно передавать три параметра… нет, возможно, 4… или 10… Ну можно перегрузить метод для 3, 4 или 10 аргументов:

```java
public class Summator {

   public static void main(String[] s){
      int x = 5;
      int y = 5;
      int res = sum(x, y);
      System.out.println(res);

   }

   public static int sum(int a, int b){
      return a+b;
   }
     
   public static int sum(int a, int b, int c){
      return a+b+c;
   }
    
   public static int sum(int a, int b, int c, int d){
      return a+b+c+d;
   }
    
   // и так дальше до 10

}
```

И компилятор это стерпит. И это даже будет работать. Но пожалейте же себя!

Если количество аргументов заведомо неизвестно, есть специальная запись - **(int ... nums)**:

```java
public class Summator {

   public static void main(String[] s){
      int x = 5;
      int y = 5;
       //мы можем передать сколько угодно параметров
      int res = sum(x, y, 1, 3, 4, 5, 6, 7, 8);
      //или даже передать массив
      int[] ar = new int[]{1, 2, 5, 7, 11};
      int res2 = sumData(ar);  
      System.out.println(res);
      System.out.println(res2);

   }

   public static int sum(int ... nums){
       int res=0;
       for(int i: nums){
           res+=i;
       }
       return res;
   }

}
```



## 2.4 Строки String

[Начало главы](#2-Базовый-синтаксис-Java)

### 2.4.1 Строки VS массив символов

В некоторых языках строки это массив символов

```java
char[] charArray = {’a’, ’b’, ’c’};
```

Но в java это отдельный **неизменяемый** тип данных (в отличие от массивов)

```java
String hello = "Hello";
```

Этот тип данных мы в любой момент можем легко перевести в массив символов

```java
char[] charsFromString = hello.toCharArray();
```

В тоже время массив символов тоже можно легко превратить в массив

```java
String string = new String(charArray);
```



### 2.4.2 Где хранятся строки?

Все строки хранятся в "String constant pool". Если компилятор встречает строку, то он заглядывает в строковый пул, если там есть такая же строка, то переиспользует её, иначе создаёт её там. 

```java
String str1 = "value"; 
```

Однако, если при создание строки используется оператор `new`, то он создаётся не в строковом пуле, а в heap.

```java
//1. String Literal "value" - created in the "String constant pool"
//2. String Object - created on the heap
String str2 = new String("value");
```



### 2.4.3 String vs StringBuffer vs StringBuilder

- Immutability : String
- Thread Safety : String(immutable), StringBuffer
- Performance : StringBuilder (especially when a number of modifications are made.)



## 2.5 Управляющие конструкции

[Начало главы](#2-Базовый-синтаксис-Java)

### 2.5.1 Оператор if



```java
if (weatherIsGood) {
	walkInThePark();
} else {
	learnJavaOnStepic();
}
```



### 2.5.2 Оператор switch



```java
switch (digit) {
    case 0:
    	text = "zero";
    break;
    case 1:
    	text = "one";
    break;
    // ...
    default:
    	text = "???";
}
```



### 2.5.3 Цикл while



```java
while (haveTime() && haveMoney()) {
	goShopping();
}
```



### 2.5.4 Цикл do while



```java
do {
	goShopping();
} while (haveTime() && haveMoney());
```



### 2.5.5 Цикл for



```java
for (int i = 0; i < args.length; i++) {
	System.out.println(args[i]);
}
```



### 2.5.6 Цикл foreach



```java
for (String arg : args) {
	System.out.println(arg);
}
```



### 2.5.7 Оператор break



```java
boolean found = false;
for (String element : haystack) {
    if (needle.equals(element )) {
        found = true;
        break;
    }
}
```



### 2.5.8 Оператор continue



```java
int count = 0;
for (String element : haystack) {
    if (!needle.equals(element)) {
    	continue;
    }
    count++;
}
```



### 2.5.9 Метки



```java
boolean found = false;
outer:
for (int[] row : matrix) {
    for (int x : row) {
        if (x > 100) {
            found = true;
            break outer;
        }
    }
}
```



# 3. Объекты, классы и пакеты в Java

[К содержанию](#0-Содержание)



## 3.1 Основы ООП

[Начало главы](#3-Объекты-классы-и-пакеты-в-Java)

### 3.1.1 Абстракция

Выделение важных сущностей и свойств реального мира для их моделирования в программе.

### 3.1.2 Инкапсуляция

Объединение внутри класса данных и операций с ними; защита данных и других деталей реализации от прямого доступа.

### 3.1.3 Наследование

Возможность создания производных классов на основе существующих.

### 3.1.4 Полиморфизм

Возможность использования производного класса там, где разрешен экземпляр базового  класса; при этом вызываются методы, переопределенные в производном  классе.

## 3.2 Пакеты и модификаторы доступа

[Начало главы](#3-Объекты-классы-и-пакеты-в-Java)

| N/A                            | Public | Protected | Default | Private |
| ------------------------------ | ------ | --------- | ------- | ------- |
| Same Class                     | Y      | Y         | Y       | Y       |
| Same Package Subclass          | Y      | Y         | Y       | N       |
| Same Package Non-subclass      | Y      | Y         | Y       | N       |
| Different Package Subclass     | Y      | Y         | N       | N       |
| Different Package Non-subclass | Y      | N         | N       | N       |

- Top-level Classes & interfaces cannot be `private` or `protected`
- Methods declared `public` in superclass must be `public` in all subclasses
- Methods declared `protected` in superclass must be `public` or `protected` in subclasses
- Private methods are not inherited



## 3.3 Объявление класса

[Начало главы](#3-Объекты-классы-и-пакеты-в-Java)



## 3.4 Наследование. Класс Object

[Начало главы](#3-Объекты-классы-и-пакеты-в-Java)



## 3.5 Абстрактные классы и интерфейсы

[Начало главы](#3-Объекты-классы-и-пакеты-в-Java)



# 4. Обработка ошибок, исключения, отладка

[К содержанию](#04-Обработка-ошибок-исключения-отладка)



## 4.1 Знакомство с исключениями

[Начало главы](#4-Обработка-ошибок-исключения-отладка)



### 4.1.1 Типы исключений

Есть три типа исключений:

1. **Checked Exceptions:** Notified by the compiler at compile-time
2. **Unchecked Exceptions:** Runtime Exceptions
3. **Errors:** Problems that arise beyond the control of the user and programmer, e.g. stack overflow



### 4.1.2 Иерархия ислючений

![Exception Hierarchy](img/687474703a2f2f63646e636f6e747269627574652e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f457863657074696f6e2d696e2d6a617661312e706e67.png)



### 4.1.3 Создание собственного исключения



```java
public class CalculatorException extends RuntimeException {
    public CalculatorException(String message) {
    	super(message);
    }
    public CalculatorException(String message, Throwable cause) {
    	super(message, cause);
    }
}
```

###  



## 4.2 Обработка исключений. Try-catch

[Начало главы](#4-Обработка-ошибок-исключения-отладка)



### 4.2. Перехват нескольких исключений

```java
try {
	// ...
} catch (FirstException e) {
	e.printStackTrace ();
} catch (SecondException e) {
	e.printStackTrace ();
}

// since Java 7 can be replaced with:
try {
	// ...
} catch (FirstException | SecondException e) {
	e.printStackTrace ();
}
```



### 4.2. Обработка исключений finally



## 4.3 Логирование

[Начало главы](#4-Обработка-ошибок-исключения-отладка)





# 5. Ввод-вывод, доступ к файловой системе

[К содержанию](#0-Содержание)



## 5.1 Доступ к файловой системе

[Начало главы](#5-Ввод-вывод-доступ-к-файловой-системе)



## 5.2 Потоки байт

[Начало главы](#5-Ввод-вывод-доступ-к-файловой-системе)



http://java-online.ru/java-inputstream.xhtml

https://javarush.ru/quests/lectures/questcore.level08.lecture04



## 5.3 Потоки символов

[Начало главы](#5-Ввод-вывод-доступ-к-файловой-системе)



## 5.4    Продвинутые возможности

[Начало главы](#5-Ввод-вывод-доступ-к-файловой-системе)



# 6. Generics. Collections. Streams

[К содержанию](#0-Содержание)



## 6.1 Generics  

[Начало главы](#6-Generics-Collections-Streams)



## 6.2 Коллекции

[Начало главы](#6-Generics-Collections-Streams)



![Java collection](img/68747470733a2f2f6d656469612e6765656b73666f726765656b732e6f72672f77702d636f6e74656e742f75706c6f6164732f6a6176612d636f6c6c656374696f6e2e6a7067.jpeg)

### 6.2.1 Интерфейс Collection

 Базовый интерфейс для всех коллекций и других интерфейсов коллекций

```java
interface Collection<E> extends Iterable<E>
{
  boolean add(E paramE);
  boolean remove(Object paramObject);

  int size();
  boolean isEmpty();
  void clear();

  boolean contains(Object paramObject);
  boolean containsAll(Collection<?> paramCollection);
  
  boolean addAll(Collection<? extends E> paramCollection);
  boolean removeAll(Collection<?> paramCollection);
  boolean retainAll(Collection<?> paramCollection);
  

  Iterator<E> iterator();

  //A NUMBER OF OTHER METHODS AS WELL..
}
```



### 6.2.2 Интерфейс List

Наследует интерфейс Collection и представляет функциональность простых списков

```java
interface List<E> extends Collection<E>
{
  boolean addAll(int paramInt, Collection<? extends E> paramCollection);

  E get(int paramInt);
  E set(int paramInt, E paramE);

  void add(int paramInt, E paramE);
  E remove(int paramInt);

  int indexOf(Object paramObject);
  int lastIndexOf(Object paramObject);

  ListIterator<E> listIterator();
  ListIterator<E> listIterator(int paramInt);
  List<E> subList(int paramInt1, int paramInt2);
}
```



### 6.2.3 Интерфейс Queue

Интерфейс *`Queue`* расширяет *`Collection`* и объявляет поведение очередей, которые представляют собой список с дисциплиной "первый вошел, первый вышел" (***FIFO***). Существуют разные типы очередей, в которых порядок основан на некотором критерии. Очереди не могут хранить 

- **Е element()** - возвращает элемент из головы очереди. <u>Элемент не удаляется</u>. Если очередь пуста, инициируется исключение *`NoSuchElementException`*.
- **Е remove()** - удаляет элемент из головы очереди, возвращая его. Инициирует исключение *`NoSuchElementException`*, если очередь пуста
- **Е peek()** \- возвращает элемент из головы очереди. Возвращает *`null`*, если очередь пуста. <u>Элемент не удаляется.</u>
- **Е роll()** \- возвращает элемент из головы очереди и <u>удаляет</u> его. Возвращает *`null`*, если очередь пуста.
- **boolean offer(Е оbj)** - пытается добавить *оbj* в очередь. Возвращает *`true`*, если *оbj* добавлен, и *`false`* в противном случае.



```java
Queue<String> queue = new LinkedList<>();
queue.offer("Харьков");
queue.offer("Киев");
queue.offer("Москва");
queue.offer("Питер");

System.out.println(queue.peek());

String town;
while ((town = queue.poll()) != null) {
    System.out.println(town);
}
```



### 6.2.4 Интерфейс Deque

Интерфейс *`Deque`* появился в Java 6. Он расширяет *`Queue`* и описывает поведение двунаправленной очереди. Двунаправленная очередь может функционировать как стандартная очередь ***FIFO*** либо как стек ***LIFO***.

- **void addFirst(Е obj)**  - добавляет *obj* в голову двунаправленной очереди. Возбуждает исключение *`IllegalStateException`*, если в очереди ограниченной <u>емкости нет места</u>.
- **void addLast(Е obj)** - добавляет *obj* в хвост двунаправленной очереди. Возбуждает исключение *`IllegalStateException`*, если в очереди ограниченной <u>емкости нет места</u>.
- **Е getFirst()** - возвращает первый элемент двунаправленной очереди. Объект из очереди <u>не удаляется</u>. В случае пустой двунаправленной очереди возбуждает  исключение *`NoSuchElementException`*.
- **Е getLast()** - возвращает последний элемент двунаправленной очереди. Объект из  очереди <u>не удаляется</u>. В случае пустой двунаправленной очереди возбуждает исключения *`NoSuchElementException`*.
- **boolean offerFirst(Е obj)** - пытается добавить *obj* в голову двунаправленной очереди. Возвращает *`true`*, если *obj* добавлен, и *`false`* в противном случае. Таким образом, этот метод возвращает *`false`* при попытке добавить *obj* в полную двунаправленную очередь ограниченной емкости.
- **boolean offerLast(E obj)** - пытается добавить *obj* в хвост двунаправленной очереди. Возвращает *`true`*, если *obj* добавлен, и *`false`* в против ном случае.
- **Е рор()** - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно <u>удаляя его из очереди</u>. Возбуждает исключение *`NoSuchElementException`*, если очередь пуста.
- **void push(Е obj)** - добавляет элемент в голову двунаправленной очереди. Если в очереди фиксированного объема <u>нет места</u>, возбуждает исключение *`IllegalStateException`*.
- **Е peekFirst()** - возвращает элемент, находящийся в голове двунаправленной очереди. Возвращает *`null`*, если очередь пуста. Объект из очереди <u>не удаляется</u>.
- ***Е peekLast()*** - возвращает элемент, находящийся в хвосте двунаправленной очереди. Возвращает *`null`*, если очередь пуста. Объект из очереди <u>не удаляется</u>.
- **Е pollFirst()** - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно <u>удаляя</u> его из очереди. Возвращает *`null`*, если очередь пуста.
- **Е pollLast()** - возвращает элемент, находящийся в хвосте двунаправленной очереди, одновременно <u>удаляя</u> его из очереди. Возвращает *`null`*, если очередь пуста.
- **Е removeLast()** - возвращает элемент, находящийся в конце двунаправленной очереди, <u>удаляя</u> его в процессе. Возбуждает исключение *`NoSuchElementException`*, если очередь пуста.
- **Е removeFirst()** - возвращает элемент, находящийся в голове двунаправленной очереди, одновременно <u>удаляя</u> его из очереди. Возбуждает исключение *`NoSuchElementException`*, если очередь пуста.
- **boolean removeLastOccurrence(Object obj)** - удаляет последнее вхождение *obj* из двунаправленной очереди. Возвращает *`true`* в случае успеха и *`false`* <u>если очередь не содержала *ob</u>j*.
- **boolean removeFirstOccurrence(Object obj)** - удаляет первое вхождение *obj* из двунаправленной очереди. Возвращает *`true`* в случае успеха и *`false`*, <u>если очередь не содержала *obj*.</u>



## 6.3 Функциональные интерфейсы  

[Начало главы](#6-Generics-Collections-Streams)


## 6.4 Stream API  

[Начало главы](#6-Generics-Collections-Streams)
